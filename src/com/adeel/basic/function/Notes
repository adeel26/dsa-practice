Java Method Parameter Behavior (Pass-by-Value)

Java is always pass-by-value â€” meaning it passes a copy of the variable to the method.
But how that copy behaves depends on whether itâ€™s a primitive or a reference type.

ğŸ”¹ 1. Primitive Types (int, double, boolean, etc.)

Java passes a copy of the value.

Changing it inside a method does NOT affect the original variable.

void changeValue(int x) {
    x = 10;
}

int num = 5;
changeValue(num);
System.out.println(num); // still 5 âŒ


ğŸ§© Why?
Because x got its own copy â€” changing it doesnâ€™t touch num.

ğŸ”¹ 2. Reference Types (Arrays, Objects, etc.)

Java passes a copy of the reference (address).

So inside the method, you can modify the objectâ€™s contents,
but not replace the reference itself.

âœ… Example (array)
void modifyArray(int[] arr) {
    arr[0] = 100; // modifies original array
}

int[] nums = {1, 2, 3};
modifyArray(nums);
System.out.println(nums[0]); // 100 âœ…


But if you reassign the array:

void modifyArray(int[] arr) {
    arr = new int[]{9, 9, 9}; // new reference, doesn't affect original
}


â†’ The original array stays unchanged.

ğŸ”¹ 3. Strings

String is a reference type, but immutable (cannot be changed after creation).

So if you try to â€œmodifyâ€ a string, Java actually creates a new object.

void changeString(String s) {
    s = s + " World"; // new String created
}

String text = "Hello";
changeString(text);
System.out.println(text); // still "Hello" âŒ


âœ… To update it, you must assign back:

text = text + " World";

ğŸ—ï¸ Key Takeaways
Type	Whatâ€™s Passed	Can Modify Original?	Notes
Primitive	Copy of value	âŒ No	Independent copy
Array	Copy of reference	âœ… Yes (elements)	Cannot reassign reference
Object	Copy of reference	âœ… Yes (fields)	Similar to array
String	Copy of reference	âŒ No	Immutable (acts like primitive)