ğŸ§© 1. int x = 10;
âœ… Primitive type
Stored directly in the stack (inside methodâ€™s frame).
No object is created on the heap.
Super fast, simple.

ğŸ“ Example:
int x = 10;

Stack memory:
x â†’ 10

ğŸ§© 2. Integer y = new Integer(10);
âŒ Always creates a new object in the heap.
Even if another Integer(10) exists, this makes a fresh one.
Deprecated (old style).
y (the reference) sits on stack, pointing to that new heap object.

ğŸ“ Memory:
Stack: y â”€â”€â–º Heap: [Integer object with value 10]

ğŸ§© 3. Integer z = Integer.valueOf(10);
âœ… Wrapper class (Integer object), but uses caching for performance.
Still stored on heap, but may reuse an existing object from the cache pool (for -128 to 127).
So not every call creates a new one.
Reference (z) itself is on stack, pointing to heap object.

ğŸ“ Memory:
Stack: z â”€â”€â–º Heap: [shared Integer object with value 10]

-------------------------------------------------------

So if I do Integer z = Integer.valueOf(130); then ?

Integer z1 = Integer.valueOf(130);
Integer z2 = Integer.valueOf(130);
System.out.println(z1 == z2);

Output:
false

Why â“
The Integer cache range is from -128 to 127.

Any value outside this range (like 130) creates a new object each time.
â†’ So z1 and z2 are different objects on the heap.

ğŸ“ Memory view:
Stack: z1 â”€â”€â–º Heap: [Integer(130)]
       z2 â”€â”€â–º Heap: [Integer(130)]  â† different object!


If you try with a cached value:

Integer a = Integer.valueOf(100);
Integer b = Integer.valueOf(100);
System.out.println(a == b);

âœ… Output:
true

So rule of thumb:
Range	        Behavior
-128 to 127	    Reuses cached object â†’ == true
Outside that	Creates new object â†’ == false


ğŸ’¡ Note:
Even though == can be false for large numbers,
.equals() will always be true because it compares values:

System.out.println(z1.equals(z2)); // true


--------------------------------------------


ğŸ’¡ 1ï¸âƒ£ Where is the Integer cache stored?
Yes â€” itâ€™s stored in the heap, just like the String pool (also heap).
But:
String pool â†’ a special memory area inside heap for all string literals.
Integer cache â†’ a small static array inside the Integer class that holds pre-created Integer objects from -128 to 127.

ğŸ’¡ 2ï¸âƒ£ What happens when you call Integer.valueOf(x)?
Integer i = Integer.valueOf(100);

JVM checks if 100 is between -128 and 127.
If yes â†’ returns the existing cached object reference from the IntegerCache array.
If not â†’ creates a new Integer object in heap and returns it (not stored in cache).

So:
Range [-128,127]  â†’ from cache
Outside range     â†’ new object in heap

ğŸ’¡ 3ï¸âƒ£ Does the new object go into the cache?
âŒ No.
The cache is fixed-size and created once when Integer class loads.
New objects outside that range are just regular heap objects â€” they do not get added to the cache.

ğŸ’¡ 4ï¸âƒ£ Visualization
Heap:
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ IntegerCache:            â”‚
 â”‚ [-128]â†’ObjA              â”‚
 â”‚ [-127]â†’ObjB              â”‚
 â”‚  ...                     â”‚
 â”‚ [127] â†’ObjZ              â”‚
 â”‚                          â”‚
 â”‚ New Integer(130) â†’ ObjX  â”‚  â† separate, not cached
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Stack:
   i â†’ ObjA
   j â†’ ObjX



When the Integer class is loaded by the JVM, it creates and stores all Integer objects from -128 to 127 in memory once.
These objects live inside a private static array called the IntegerCache.

